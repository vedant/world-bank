#!/usr/bin/env python
# -*- coding: ascii -*-
#-----------------------------------------------------------------------------
"""Timeseries analysis of data from "http://data.worldbank.org/country/".
    Data is stored at ../data/
"""

__author__ = 'Vedant Misra'
__license__ = 'BSD'
__vcs_id__ = '$Id$'
__version__ = '0.1'
__date__ = "2010-11-30"

# Initialization
import os
from xml.etree import ElementTree
from scraper import generateCountries
import pickle
import numpy
import pytsa
import matplotlib.pyplot as plt
import scipy
from scipy import stats
import urllib
from scipy import stats
import rpy2.robjects as robjects

# Class definitions
class Country():
    def __init__(self, id, name):
	self.id = id
	self.name = name
	self.indicators = []

class Indicator():
    def __init__(self, id, name):
	self.id = id
	self.name = name
	self.values = []
    def __cmp__(self, other):
	return cmp(self.name, other.name)

class Year():
    def __init__(self, year, value):
	self.year = year
	self.value = value
    def __cmp__(self, other):
	return cmp(self.year, other.year)

def loadPickle(item):
    pickled = open(os.path.join(os.pardir, 'pickled', \
	item[0] + ".pickle"), 'r')
    country = pickle.load(pickled)
    return country


def plotLinearRegression(item, indicatorList):
    """Saves to file a linear regression plot of any indicator in item
    that contains at least 30 values"""
    country = loadPickle(item)
    print len(item[1])*"-" + "\n" + item[1] + "\n" + len(item[1]) * "-"
    country.indicators.sort()
    for indicator in country.indicators:
	indicator.values.sort()
	if indicator.id in indicatorList:
	#if len(indicator.values) >= 40:
	#if indicator.id == "NY.GDP.MKTP.KD":
	    print "  ", indicator.name
	    xvals = []
	    yvals = []
	    for entry in indicator.values:
		xvals.append(entry.year)
		yvals.append(entry.value)
	    (a, b, r, tt, err) = stats.linregress(xvals, yvals)
	    regVals = scipy.polyval([a, b], xvals)
	    plt.title(indicator.name + "\n" + item[1])
	    plt.plot(xvals, yvals, 'k.')
	    plt.plot(xvals, regVals, 'r.-')
	    plt.legend(['data', 'regression'])

	    dir = os.path.join(os.pardir, 'plots', 'linear_regressions',
		indicator.id)
	    if not os.path.exists(dir):
		os.makedirs(dir)

	    plt.savefig(os.path.join(dir,item[0] + ".pdf"))
	    plt.clf()

def generateArray(item):
    """Generate (padded) numpy array for the data in each .pickle"""
    country = loadPickle(item)
    print "Generating array for", item[1]
    numIndicators = len(country.indicators)
    numValues = 2010 - 1960
    countryArray = numpy.ones((numIndicators, numValues))
    countryArray = countryArray * float('nan')
    indicatorList = []
    country.indicators.sort()
    m = -1
    f = open("/Users/vedant/Desktop/world_bank_sample_data.csv", 'a')
    for indicator in country.indicators:
	if indicator.id.split(".")[0] == "NY":
	    m += 1
	    indicator.values.sort()
	    indicatorList.append(item[1] + "." + str(indicator.id))
	    n = -1
	    for y in range(1960, 2010):
		n += 1
		for entry in indicator.values:
		    if entry.year == y:
			countryArray[m][n] = entry.value
    for i in range(len(indicatorList)):
	f.write(indicatorList[i] + ",")
	for j in range(len(countryArray[i])):
	    f.write(str(countryArray[i][j]) + ",")
	f.write("\n")
    #pickled2 = open(os.path.join(os.pardir, 'arrays', \
    #	item[0] + "_array.pickle"), 'w')
    #pickle.dump([countryArray, indicatorList], pickled2)


# initialize countries, a list of Country instances, as temporary
# storage for mergePickles
countries = []
def mergePickles(item):
    """Merge the .pickle files generated by pickleCountry() into
    one large database called complete.pickle
    """
    country = loadPickle(item)
    print "merging pickle for", item[1]
    countries.append(country)

def geoNamesLocation(item):
    """Returns [name, latitude, longitude, regioncode] of a country 
    contained in item
    """
    name = item[1]
    print name
    countryID = name
    if name == "Hong Kong SAR":
	name = "Hong Kong"
	countryID = "Hong Kong"
    if item[0] == "brunei-darussalam":
	name = "Brunei"
	countryID = "Brunei"
    if item[0] == "congo-dem-rep-of":
	name = "Congo-Kinshasa"
	countryID = "Congo [DRC]"
    if item[0] == "congo-rep":
	name = "Republic of the Congo"
	countryID = "Congo [Republic]"
    if name == "Cote d'Ivoire":
	name = "Ivory Coast"
	countryID = "Ivory Coast"
    if name == "Faeroe Islands":
	name = "Faroe Islands"
	countryID = "Faroe Islands"
    if item[0] == "korea-rep-of":
	name = "South Korea"
	countryID = "South Korea"
    if item[0] == "korea-d-p-r-of":
	name = "North Korea"
	countryID = "North Korea"
    if name == "Kyrgyz Republic":
	name = "Kyrgyzstan"
	countryID = "Kyrgyzstan"
    if item[0] == "lao-p-d-r":
	name = "Laos"
	countryID = "Laos"
    if item[0] == "macao-sar-china":
	name = "Macao"
	countryID = "Macau"
    if item[0] == "myanmar":
	name = "Myanmar"
	countryID = "Myanmar [Burma]"
    if item[0] == "russian-federation":
	name = "Russia"
	countryID = "Russia"
    if item[0] == "slovak-republic":
	name = "Slovakia"
	countryID = "Slovakia"
    if item[0] == "st-lucia":
	name = "Saint Lucia"
	countryID = "Saint Lucia"
    if item[0] == "west-bank-and-gaza":
	name = "Gaza"
	countryID = "Palestinian Territories"
   
    url1 = "%20".join(name.split(" "))
    url0 = "http://ws.geonames.org/search?name="
    url = url0 + url1
    webFile = urllib.urlopen(url)
    localFile = open("tmp.xml", 'w')
    localFile.write(webFile.read())
    webFile.close()
    localFile.close()
    tree = ElementTree.parse("tmp.xml")
    geonames = tree.getroot().getchildren()
    foundEntry = False
    for geoname in geonames[1:]:
	if countryID == geoname.find("countryName").text and (
	    name == geoname.find("name").text):
	    found = geoname
	    foundEntry = True
    if not foundEntry:
	if len(geonames) == 2:
	    print "Forced match!"
	    found = geonames[1]
    print url
    countryName = found.find("name").text
    latitude = float(found.find("lat").text)
    longitude = float(found.find("lng").text)
    regionCode = 1 #for Country, as opposed to district or city.
 
    if countryName[-5:] == "ncipe": countryName = "Sao Tome and Principe"
    return [countryName, latitude, longitude, regionCode]

def generateDataset(indicatorList, countryList, proj=0):
    masterDataset = {}
    headerlist = ['date', 'id', 'longitude', 'latitude', 'value']
    dataset = numpy.array([0,0,0,0,0])
    
    gisIDs = {}
    gis = open(os.path.join(os.pardir, 'code', 'gis_country_ids.csv'),'r')
    for row in gis:
	row = row.strip()
	[id, name] = row.split("\t")
	gisIDs[name] = id

    for indicator in indicatorList:
	masterDataset[indicator] = {
	    'datasetid': indicator,
	    'datasetname' : None,
	    'header' : headerlist,
	    'data' : dataset}

    for item in countryList:
	country = loadPickle(item)
	name = geoNamesLocation(item)[0]
	if name == "Ivory Coast": name = "Cote d'Ivoire"
	if name == "Congo-Kinshasa": name = "Democratic Republic of the Congo"
	if name == "Gaza": name = "Palestina"
	if name == "Republic of the Congo": name = "Republic of Congo"
	if name == "U.S. Virgin Islands": name = "Virgin Islands, U.S."
	id = int(gisIDs[name])
	lat = geoNamesLocation(item)[1]
	lon = geoNamesLocation(item)[2]
	for indicator in country.indicators:
	    if indicator.id in indicatorList:
		masterDataset[indicator.id]['datasetname'] = indicator.name
		for entry in indicator.values:
		    newrow = [entry.year, id, float(lon), float(lat), entry.value]
		    masterDataset[indicator.id]['data'] = numpy.vstack(
			[masterDataset[indicator.id]['data'], newrow])
		if proj > 0:
		    projections = genProjections(indicator, proj)
		    for projection in projections:
			newrow = [projection[0], id, float(lon), float(lat), projection[1]]
			masterDataset[indicator.id]['data'] = numpy.vstack(
			    [masterDataset[indicator.id]['data'], newrow])    
    for key in masterDataset.keys():
	masterDataset[key]['data'] = masterDataset[key]['data'][1:]
    return masterDataset

def genProjections(indicator, fc):
    yvals = []
    xvals = []
    for entry in indicator.values:
	xvals.append(entry.year)
	yvals.append(entry.value)
    (xvals2, yvals2, r, p) = pytsa.linreg(xvals, yvals, 10)
    robjects.r('library(stats)')
    robjects.r('library(forecast)')
    data = robjects.FloatVector(yvals)
    arima = robjects.r('auto.arima')
    try:
	arimafit = arima(data)
	forecast = robjects.r('forecast')
	fcast = forecast(arimafit)
	yvals2 = yvals
	yvals2.extend(list(fcast[3]))
	#print "ARIMA FORECASTING SUCCEEDED"
    except:
	print "ARIMA FORECASTING FAILED"
    ret = []
    xvals2 = xvals2[-10:]
    yvals2 = yvals2[-10:]
    for i in range(len(xvals2)):
	ret.append([xvals2[i], yvals2[i]])
    #print indicator.name
    #for i in range(len(xvals)):
#	print xvals[i], yvals[i]
#    print "------"
#    for i in range(len(xvals2)):
#	print xvals2[i], yvals2[i]
    return ret
    #TODO: insert errors into ret

def drawPCA(indicatorList, countryList):
    #dict = {}
    #for indicator in indicatorList:
#	dict[indicator] = 0
#    for item in countryList:
#	print item[1]
#	country = loadPickle(item)
#	for indicator in indicatorList:
#	    idnames = []
#	    for id in country.indicators:
#		idnames.append(id.id)
#	    
#	    if indicator in idnames:
#		dict[indicator] += 1
#    
#    keys = dict.keys()
#    keys.sort()
#    for key in keys:
#	print key, dict[key]
#    exit() 

    countryList = countryList[:]
    indicatorList.sort()
    countryList.sort()
    matrix = numpy.ones((len(indicatorList), len(countryList)))
    matrix = matrix * float('nan')
    c = -1
    for item in countryList:
	c += 1
	print item[1]
	country = loadPickle(item)
	i = -1
	for indicator in country.indicators:
	    if indicator.id in indicatorList:
		i += 1
		indicator.values.sort()
		v1 = indicator.values[-1].value
		v0 = None
		diff = 0.0
		j = -1
		if v1 != None:
		    while (v0 == None) and (indicator.values[j] != indicator.values[0]):
			j -= 1
			diff += 1
			v0 = indicator.values[j].value
		    if v0 == None:
			next = float('nan')
		    elif v0 == 0:
			next = 0
		    else:
			next = ((float(v1) / float(v0)) - 1) / diff
		    
		else:
		    next = float('nan')
		matrix[i][c] = next

    z = numpy.any(numpy.isnan(matrix), axis=0)
    remove = []
    for i in range(len(z)):
	if z[i]:
	    remove.append(i)
    
    matrix = numpy.delete(matrix, remove, axis=1)
    

    #z = numpy.any(numpy.isnan(matrix), axis=0)
    #matrix2 = numpy.delete(matrix, z, axis=1)
    #matrix2 = numpy.compress(
    #	numpy.array([float('nan')]), matrix, axis=1)
    #matrix2 = numpy.array([[],[]])

    #(n, q) = matrix.shape
    #print "n, q", n, q
    #for i in range(q-1):
#	allvalid = True
#	for j in range(n-1):
#	    if numpy.isnan(matrix[j,i]):
#		allvalid = False
#	if allvalid == False:
#	    matrix = numpy.delete(matrix, i, 1)
#	    countryList.pop(i)
    for i in range(len(countryList)):
	if i not in remove:
	    print countryList[i][1] + "\t",
    print ""
    for item in indicatorList:
	print item
    scipy.savetxt("/Users/vedant/Desktop/pca_vals.csv", matrix)

def customComp(first, second):
    return cmp(first[0], second[0])

lengths = []
def printContents(item):
    print item[1]
    country = loadPickle(item)
    for indicator in country.indicators:
	found = False
	for element in lengths:
	    if element[2] == indicator.id:
		element[0] += len(indicator.values)
		found = True
	if found == False:
	    lengths.append([len(indicator.values), indicator.name, indicator.id])
    lengths.sort(customComp)
    lengths.reverse()
    for element in lengths:
	print element[0], "\t", element[2], "\t", element[1]


def pickleCountry(item):
    """Write a .pickle file for each country in country_list.csv
    """
    id = item[0]; name = item[1]
    print "Parsing data for", name
    file = os.path.join(os.pardir, 'data', item[0] + "_en.xml")
    tree = ElementTree.parse(file)
    country = Country(id, name)
    data = tree.getroot()
    for datum in data.getchildren():
	indicator = datum.find("indicator")
	if indicator.attrib["id"] != "":
	    id = indicator.attrib["id"]
	    name = indicator.text
	    year = int(datum.find("year").text)
	    value = float(datum.find("value").text)
	    
	    foundIndicator = False
	    for element in country.indicators:
		if element.id == id:
		    foundIndicator = True
		    element.values.append(Year(year, value))
	    if foundIndicator == False:
		newIndicator = Indicator(id, name)
		newIndicator.values.append(Year(year, value))
		country.indicators.append(newIndicator)
    pickled = open(os.path.join(os.pardir, 'pickled', \
	item[0] + ".pickle"), 'w')
    pickle.dump(country, pickled)


def genPlots(dataset):
    print dataset.keys()
    indicatorList = dataset.keys()
    ids = {}
    for row in (open(os.path.join(os.pardir, 'code', 'gis_country_ids.csv'))):
	row = row.strip()
	ids[int(row.split("\t")[0])] = row.split("\t")[1]
    indicatorList.sort()
    for indicator in indicatorList:
	print "generating plots for", indicator
	currData = dataset[indicator]['data']
	xvals = {}
	yvals = {}
	for row in currData:
	    if row[1] in xvals.keys():
		xvals[row[1]].append(row[0])
		yvals[row[1]].append(row[4])
	    else:
		xvals[row[1]] = [row[0]]
		yvals[row[1]] = [row[4]]
	for countryID in xvals.keys():
	    print "plotting for", ids[int(countryID)]
	    plt.title(dataset[indicator]['datasetname'] + "\n" + ids[int(countryID)])
	    plt.plot(xvals[countryID][:-10], yvals[countryID][:-10], 'k.')
	    plt.plot(xvals[countryID][-10:], yvals[countryID][-10:], 'r.')
	    dir = os.path.join(os.pardir, 'plots', 'projections', indicator)
	    if not os.path.exists(dir):
		os.makedirs(dir)
	    plt.savefig(os.path.join(dir, ids[countryID] + ".pdf"))
	    plt.clf()

if __name__=='__main__':
    countryList = generateCountries(
	os.path.join(os.pardir, 'code', 'country_list.csv'))
    indicatorList = ['AG.LND.ARBL.HA.PC',
		      'AG.PRD.LVSK.XD',
		      'AG.PRD.CROP.XD',
		      'AG.LND.TRAC.ZS',
		      'AG.LND.CREL.HA',
		      'AG.YLD.CREL.KG',
		      'BM.GSR.MRCH.CD',
		      'BM.GSR.NFSV.CD',
		      'BN.RES.INCL.CD',
		      'BN.GSR.GNFS.CD',
		      'BN.CAB.XOKA.CD',
		      'BX.KLT.DINV.CD.WD',
		      'BX.KLT.DINV.WD.GD.ZS',
		      'BX.GSR.NFSV.CD',
		      'BX.GSR.MRCH.CD',
		      'DT.ODA.ALLD.KD',
		      'DT.ODA.ODAT.CD',
		      #'EG.USE.COMM.CL.ZS',
		      #'EG.USE.CRNW.ZS',
		      #'EG.USE.CRNW.KT.OE',
		      #'EG.ELC.PROD.KH',
		      #'EG.USE.PCAP.KG.OE',
		      'FD.RES.LIQU.AS.ZS',
		      'FI.RES.XGLD.CD',
		      'FI.RES.TOTL.CD',
		      'FP.CPI.TOTL.ZG',
		      'FS.AST.PRVT.GD.ZS',
		      'IP.TMK.TOTL',
		      'IP.JRN.ARTC.SC',
		      'IS.AIR.PSGR',
		      'IS.AIR.GOOD.MT.K1',
		      'IT.CEL.SETS',
		      'IT.CEL.SETS.P2',
		      'IT.MLT.MAIN',
		      'IT.MLT.MAIN.P2',
		      'MS.MIL.MPRT.KD',
		      'MS.MIL.TOTL.P1',
		      'MS.MIL.TOTL.TF.ZS',
		      'NE.RSB.GNFS.CN',
		      'NE.RSB.GNFS.ZS',
		      'NE.TRD.GNFS.ZS',
		      'NY.GDP.MKTP.CN',
		      'NY.ADJ.DMIN.CD',
		      'NY.ADJ.DNGY.CD',
		      'NY.ADJ.DCO2.CD',
		      'NY.GDP.PCAP.KN',
		      'SH.IMM.IDPT',
		      'SH.MED.PHYS.ZS',
		      'SL.TLF.CACT.ZS',
		      'SL.TLF.CACT.MA.ZS',
		      'SL.TLF.CACT.FE.ZS',
		      'SL.TLF.TOTL.IN',
		      'SP.URB.TOTL.IN.ZS',
		      'SP.RUR.TOTL.ZS',
		      'SP.POP.TOTL',
		      'SP.POP.GROW',
		      'SP.POP.65UP.TO.ZS',
		      'SP.POP.1564.TO.ZS',
		      'SP.POP.0014.TO.ZS',
		      'SP.DYN.CDRT.IN',
		      'SP.DYN.CBRT.IN',
		      'SP.DYN.TFRT.IN',
		      'SP.DYN.LE00.FE.IN',
		      'SP.DYN.LE00.IN',
		      'SP.DYN.LE00.MA.IN',
		      'TM.VAL.MRCH.CD.WT',
		      'TX.VAL.MRCH.CD.WT',
		      'VC.BTL.DETH']
    #drawPCA(indicatorList, countryList)
    for item in countryList:
	#print geoNamesLocation(item)[0]
	#plotLinearRegression(item, indicatorList)
	#generateArray(item)
	#printContents(item)
	pass
    countryList.remove(('netherlands-antilles', 'Netherlands Antilles'))
#    dataset = generateDataset(indicatorList, countryList, 10)
#    for key in dataset.keys():
#	pickled = open(os.path.join(os.pardir, 
#	    'packaged_data', key + '.pickle'), 'w')
#	pickle.dump(dataset[key], pickled)

    masterDataset = {}
    for indicator in indicatorList:
	print "loading data for indicator", indicator
	pickled = open(os.path.join(os.pardir, 'packaged_data', indicator + '.pickle'), 'r')
	indicatorData = pickle.load(pickled)
	masterDataset[indicator] = indicatorData
    genPlots(masterDataset)




